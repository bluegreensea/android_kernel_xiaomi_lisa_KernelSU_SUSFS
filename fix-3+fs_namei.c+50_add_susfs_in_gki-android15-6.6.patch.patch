--- a/50_add_susfs_in_gki-android15-6.6.patch	2025-08-28 22:47:25.723972398 +0800
+++ b/50_add_susfs_in_gki-android15-6.6.patch	2025-08-31 03:58:30.225273014 +0800
@@ -120,50 +120,70 @@
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +extern bool susfs_is_sus_android_data_d_name_found(const char *d_name);
 +extern bool susfs_is_sus_sdcard_d_name_found(const char *d_name);
-+extern bool susfs_is_inode_sus_path(struct mnt_idmap *idmap, struct inode *inode);
++extern bool susfs_is_inode_sus_path(struct inode *inode);
 +extern bool susfs_is_base_dentry_android_data_dir(struct dentry* base);
 +extern bool susfs_is_base_dentry_sdcard_dir(struct dentry* base);
 +extern const struct qstr susfs_fake_qstr_name;
 +#endif
 +
- /* [Feb-1997 T. Schoebel-Theuer]
-  * Fundamental changes in the pathname lookup mechanisms (namei)
-  * were necessary because of omirr.  The reason is that omirr needs
-@@ -1619,6 +1631,11 @@ static struct dentry *lookup_fast(struct nameidata *nd)
- {
+ #define CREATE_TRACE_POINTS
+ #include <trace/events/namei.h>
+ 
+@@ -494,6 +506,9 @@
+ 	struct path	root;
+ 	struct inode	*inode; /* path.dentry.d_inode */
+ 	unsigned int	flags;
++#ifdef CONFIG_KSU_SUSFS_SUS_PATH
++	unsigned int	state;
++#endif
+ 	unsigned	seq, m_seq;
+ 	int		last_type;
+ 	unsigned	depth;
+@@ -520,6 +535,9 @@
+ 	p->total_link_count = old ? old->total_link_count : 0;
+ 	p->saved = old;
+ 	current->nameidata = p;
++#ifdef CONFIG_KSU_SUSFS_SUS_PATH
++	p->state = 0;
++#endif
+ }
+ 
+ static void restore_nameidata(void)
+@@ -1636,6 +1648,9 @@
  	struct dentry *dentry, *parent = nd->path.dentry;
  	int status = 1;
+ 	int err;
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
-+	struct vfsmount *mnt = nd->path.mnt;
-+	unsigned int backup_next_seq = nd->next_seq;
 +	bool is_nd_state_lookup_last_and_open_last = (nd->state & ND_STATE_LOOKUP_LAST || nd->state & ND_STATE_OPEN_LAST);
 +#endif
  
  	/*
  	 * Rename seqlock is not required here because in the off chance
-@@ -1626,7 +1643,31 @@ static struct dentry *lookup_fast(struct nameidata *nd)
- 	 * going to fall back to non-racy lookup.
- 	 */
+@@ -1645,7 +1660,33 @@
  	if (nd->flags & LOOKUP_RCU) {
+ 		unsigned seq;
+ 		bool negative;
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
++		unsigned backup_next_seq;
++		
 +		if (is_nd_state_lookup_last_and_open_last && parent->d_inode) {
 +			if (susfs_is_base_dentry_android_data_dir(parent) &&
 +				susfs_is_sus_android_data_d_name_found(nd->last.name))
 +			{
-+				dentry = __d_lookup_rcu(parent, &susfs_fake_qstr_name, &nd->next_seq);
++				dentry = __d_lookup_rcu(parent, &susfs_fake_qstr_name, &seq);
 +				goto skip_orig_flow1;
 +			} else if (susfs_is_base_dentry_sdcard_dir(parent) &&
 +					   susfs_is_sus_sdcard_d_name_found(nd->last.name))
 +			{
-+				dentry = __d_lookup_rcu(parent, &susfs_fake_qstr_name, &nd->next_seq);
++				dentry = __d_lookup_rcu(parent, &susfs_fake_qstr_name, &seq);
 +				goto skip_orig_flow1;
 +			}
 +		}
 +#endif
- 		dentry = __d_lookup_rcu(parent, &nd->last, &nd->next_seq);
+ 		dentry = __d_lookup_rcu(parent, &nd->last, &seq);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +		if (is_nd_state_lookup_last_and_open_last && dentry && !IS_ERR(dentry) && dentry->d_inode && parent->d_inode && mnt) {
-+			if (susfs_is_inode_sus_path(mnt_idmap(mnt), dentry->d_inode)) {
++			if (susfs_is_inode_sus_path(dentry->d_inode)) {
 +				dput(dentry);
 +				dentry = __d_lookup_rcu(parent, &susfs_fake_qstr_name, &backup_next_seq);
 +			}
@@ -171,8 +191,8 @@
 +skip_orig_flow1:
 +#endif
  		if (unlikely(!dentry)) {
- 			if (!try_to_unlazy(nd))
- 				return ERR_PTR(-ECHILD);
+ 			if (unlazy_walk(nd))
+ 				return -ECHILD;
 @@ -1649,7 +1690,31 @@ static struct dentry *lookup_fast(struct nameidata *nd)
  			/* we'd been told to redo it in non-rcu mode */
  			status = d_revalidate(dentry, nd->flags);
@@ -195,7 +215,7 @@
  		dentry = __d_lookup(parent, &nd->last);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +		if (is_nd_state_lookup_last_and_open_last && dentry && !IS_ERR(dentry) && dentry->d_inode && parent->d_inode && mnt) {
-+			if (susfs_is_inode_sus_path(mnt_idmap(mnt), dentry->d_inode)) {
++			if (susfs_is_inode_sus_path(dentry->d_inode)) {
 +				dput(dentry);
 +				dentry = __d_lookup(parent, &susfs_fake_qstr_name);
 +			}
@@ -203,12 +223,12 @@
 +skip_orig_flow2:
 +#endif
  		if (unlikely(!dentry))
- 			return NULL;
+ 			return 0;
  		status = d_revalidate(dentry, nd->flags);
 @@ -1985,6 +2050,10 @@ static const char *handle_dots(struct nameidata *nd, int type)
- static const char *walk_component(struct nameidata *nd, int flags)
- {
- 	struct dentry *dentry;
+ 	struct inode *inode;
+ 	unsigned seq;
+ 	int err;
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	struct dentry *base = nd->path.dentry;
 +	bool is_nd_state_lookup_last = (nd->state & ND_STATE_LOOKUP_LAST);
@@ -216,53 +236,53 @@
  	/*
  	 * "." and ".." are special - ".." especially so because it has
  	 * to be able to know about the current root directory and
-@@ -1999,7 +2068,31 @@ static const char *walk_component(struct nameidata *nd, int flags)
- 	if (IS_ERR(dentry))
- 		return ERR_CAST(dentry);
- 	if (unlikely(!dentry)) {
+@@ -1882,8 +1951,32 @@ static int walk_component(struct nameidata *nd, int flags)
+ 	if (unlikely(err <= 0)) {
+ 		if (err < 0)
+ 			return err;
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +		if (is_nd_state_lookup_last && base->d_inode) {
 +			if (susfs_is_base_dentry_android_data_dir(base) &&
 +				susfs_is_sus_android_data_d_name_found(nd->last.name))
 +			{
-+				dentry = lookup_slow(&susfs_fake_qstr_name, base, nd->flags);
++				path.dentry = lookup_slow(&susfs_fake_qstr_name, base, nd->flags);
 +				goto skip_orig_flow;
 +			} else if (susfs_is_base_dentry_sdcard_dir(base) &&
 +					   susfs_is_sus_sdcard_d_name_found(nd->last.name))
 +			{
-+				dentry = lookup_slow(&susfs_fake_qstr_name, base, nd->flags);
++				path.dentry = lookup_slow(&susfs_fake_qstr_name, base, nd->flags);
 +				goto skip_orig_flow;
 +			}
 +		}
 +#endif
- 		dentry = lookup_slow(&nd->last, nd->path.dentry, nd->flags);
+ 		path.dentry = lookup_slow(&nd->last, nd->path.dentry,
+ 					  nd->flags);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
-+		if (is_nd_state_lookup_last && dentry && !IS_ERR(dentry) && dentry->d_inode && base->d_inode &&
-+			susfs_is_inode_sus_path(mnt_idmap(nd->path.mnt), dentry->d_inode))
++		if (is_nd_state_lookup_last && path.dentry && !IS_ERR(path.dentry) && path.dentry->d_inode && base->d_inode &&
++			susfs_is_inode_sus_path(path.dentry->d_inode))
 +		{
-+			dput(dentry);
-+			dentry = lookup_slow(&susfs_fake_qstr_name, base, nd->flags);
++			dput(path.dentry);
++			path.dentry = lookup_slow(&susfs_fake_qstr_name, base, nd->flags);
 +		}
 +skip_orig_flow:
 +#endif
- 		if (IS_ERR(dentry))
- 			return ERR_CAST(dentry);
- 	}
-@@ -2266,11 +2359,22 @@ static int link_path_walk(const char *name, struct nameidata *nd)
- 		const char *link;
+ 		if (IS_ERR(path.dentry))
+ 			return PTR_ERR(path.dentry);
+ 
+@@ -2155,10 +2248,21 @@ static int link_path_walk(const char *name, struct nameidata *nd)
+ 	for(;;) {
  		u64 hash_len;
  		int type;
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +		struct dentry *dentry;
 +#endif
  
- 		idmap = mnt_idmap(nd->path.mnt);
- 		err = may_lookup(idmap, nd);
+ 		err = may_lookup(nd);
  		if (err)
  			return err;
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +		dentry = nd->path.dentry;
-+		if (dentry->d_inode && susfs_is_inode_sus_path(idmap, dentry->d_inode)) {
++		if (dentry->d_inode && susfs_is_inode_sus_path(dentry->d_inode)) {
 +			// - No need to dput() here
 +			// - return -ENOENT here since it is walking the sub path of sus path
 +			return -ENOENT;
@@ -303,8 +323,8 @@
 +	nd->state |= ND_STATE_LOOKUP_LAST;
 +#endif
  
- 	return walk_component(nd, WALK_TRAILING);
- }
+ 	nd->flags &= ~LOOKUP_PARENT;
+ 	return walk_component(nd, 0);
 @@ -3402,15 +3526,57 @@ static struct dentry *lookup_open(struct nameidata *nd, struct file *file,
  	int error, create_error = 0;
  	umode_t mode = op->mode;
@@ -316,7 +336,7 @@
 +#endif
  
  	if (unlikely(IS_DEADDIR(dir_inode)))
- 		return ERR_PTR(-ENOENT);
+ 		return -ENOENT;
  
  	file->f_mode &= ~FMODE_CREATED;
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
@@ -340,7 +360,7 @@
  	dentry = d_lookup(dir, &nd->last);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	if (is_nd_state_open_last && dentry && !IS_ERR(dentry) && dentry->d_inode && mnt) {
-+		if (susfs_is_inode_sus_path(mnt_idmap(mnt), dentry->d_inode)) {
++		if (susfs_is_inode_sus_path(dentry->d_inode)) {
 +			dput(dentry);
 +			dentry = d_lookup(dir, &susfs_fake_qstr_name);
 +			found_sus_path = true;
@@ -361,18 +381,18 @@
 +skip_orig_flow2:
 +#endif
  			if (IS_ERR(dentry))
- 				return dentry;
+ 				return PTR_ERR(dentry);
  		}
 @@ -3509,6 +3675,9 @@ static const char *open_last_lookups(struct nameidata *nd,
- 	bool got_write = false;
- 	struct dentry *dentry;
- 	const char *res;
+ 	struct inode *inode;
+ 	struct path path;
+ 	int error;
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	nd->state |= ND_STATE_OPEN_LAST;
 +#endif
  
+ 	nd->flags &= ~LOOKUP_PARENT;
  	nd->flags |= op->intent;
- 
 @@ -3805,12 +3974,19 @@ static struct file *path_openat(struct nameidata *nd,
  	return ERR_PTR(error);
  }
@@ -391,7 +411,7 @@
 +	struct filename *fake_pathname;
 +#endif
  
- 	set_nameidata(&nd, dfd, pathname, NULL);
+ 	set_nameidata(&nd, dfd, pathname);
  	filp = path_openat(&nd, op, flags | LOOKUP_RCU);
 @@ -3818,6 +3994,25 @@ struct file *do_filp_open(int dfd, struct filename *pathname,
  		filp = path_openat(&nd, op, flags);
@@ -404,7 +424,7 @@
 +			restore_nameidata();
 +			filp_close(filp, NULL);
 +			// no need to do `putname(pathname);` here as it will be done by calling process
-+			set_nameidata(&nd, dfd, fake_pathname, NULL);
++			set_nameidata(&nd, dfd, fake_pathname);
 +			filp = path_openat(&nd, op, flags | LOOKUP_RCU);
 +			if (unlikely(filp == ERR_PTR(-ECHILD)))
 +				filp = path_openat(&nd, op, flags);
@@ -420,19 +440,19 @@
  	return filp;
  }
 @@ -3859,6 +4054,10 @@ static struct dentry *filename_create(int dfd, struct filename *name,
- 	int type;
  	int err2;
  	int error;
+ 	bool is_dir = (lookup_flags & LOOKUP_DIRECTORY);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	struct dentry *base;
 +	struct vfsmount *mnt;
 +#endif
  
- 	error = filename_parentat(dfd, name, reval_flag, path, &last, &type);
- 	if (error)
-@@ -3880,8 +4079,37 @@ static struct dentry *filename_create(int dfd, struct filename *name,
- 	if (last.name[last.len] && !want_dir)
- 		create_flags = 0;
+ 	/*
+ 	 * Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any
+@@ -3782,7 +3977,36 @@ static struct dentry *filename_create(int dfd, struct filename *name,
+ 	 */
+ 	lookup_flags |= LOOKUP_CREATE | LOOKUP_EXCL;
  	inode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	base = path->dentry;
@@ -441,27 +461,26 @@
 +		if (susfs_is_base_dentry_android_data_dir(base) &&
 +			susfs_is_sus_android_data_d_name_found(last.name))
 +		{
-+			dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base,
-+				      reval_flag | create_flags);
++			dentry = __lookup_hash(&susfs_fake_qstr_name, base,
++				      lookup_flags);
 +			goto skip_orig_flow;
 +		} else if (susfs_is_base_dentry_sdcard_dir(base) &&
 +				   susfs_is_sus_sdcard_d_name_found(last.name))
 +		{
-+			dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base,
-+				      reval_flag | create_flags);
++			dentry = __lookup_hash(&susfs_fake_qstr_name, base,
++				      lookup_flags);
 +			goto skip_orig_flow;
 +		}
 +	}
 +#endif
- 	dentry = lookup_one_qstr_excl(&last, path->dentry,
- 				      reval_flag | create_flags);
+ 	dentry = __lookup_hash(&last, path->dentry, lookup_flags);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	if (dentry && !IS_ERR(dentry) && dentry->d_inode && base->d_inode && mnt &&
-+		susfs_is_inode_sus_path(mnt_idmap(mnt), dentry->d_inode))
++		susfs_is_inode_sus_path(dentry->d_inode))
 +	{
 +		dput(dentry);
-+		dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base,
-+				      reval_flag | create_flags);
++		dentry = __lookup_hash(&susfs_fake_qstr_name, base,
++				      lookup_flags);
 +	}
 +skip_orig_flow:
 +#endif
@@ -477,10 +496,10 @@
 +	struct vfsmount *mnt;
 +#endif
  retry:
- 	error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
- 	if (error)
+ 	name = filename_parentat(dfd, getname(pathname), lookup_flags,
+ 				&path, &last, &type);
 @@ -4241,7 +4473,33 @@ int do_rmdir(int dfd, struct filename *name)
- 		goto exit2;
+ 		goto exit1;
  
  	inode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
@@ -490,29 +509,29 @@
 +		if (susfs_is_base_dentry_android_data_dir(base) &&
 +			susfs_is_sus_android_data_d_name_found(last.name))
 +		{
-+			dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++			dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +			goto skip_orig_flow;
 +		} else if (susfs_is_base_dentry_sdcard_dir(base) &&
 +				   susfs_is_sus_sdcard_d_name_found(last.name))
 +		{
-+			dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++			dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +			goto skip_orig_flow;
 +		}
 +	}
 +#endif
- 	dentry = lookup_one_qstr_excl(&last, path.dentry, lookup_flags);
+ 	dentry = __lookup_hash(&last, path.dentry, lookup_flags);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	if (dentry && !IS_ERR(dentry) && dentry->d_inode && base->d_inode && mnt &&
-+		susfs_is_inode_sus_path(mnt_idmap(mnt), dentry->d_inode))
++		susfs_is_inode_sus_path(dentry->d_inode))
 +	{
 +		dput(dentry);
-+		dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++		dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +	}
 +skip_orig_flow:
 +#endif
  	error = PTR_ERR(dentry);
  	if (IS_ERR(dentry))
- 		goto exit3;
+ 		goto exit2;
 @@ -4360,6 +4618,10 @@ int do_unlinkat(int dfd, struct filename *name)
  	struct inode *inode = NULL;
  	struct inode *delegated_inode = NULL;
@@ -522,10 +541,10 @@
 +	struct vfsmount *mnt;
 +#endif
  retry:
- 	error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
- 	if (error)
+ 	name = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
+ 	if (IS_ERR(name))
 @@ -4374,7 +4636,33 @@ int do_unlinkat(int dfd, struct filename *name)
- 		goto exit2;
+ 		goto exit1;
  retry_deleg:
  	inode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
@@ -535,41 +554,41 @@
 +		if (susfs_is_base_dentry_android_data_dir(base) &&
 +			susfs_is_sus_android_data_d_name_found(last.name))
 +		{
-+			dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++			dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +			goto skip_orig_flow;
 +		} else if (susfs_is_base_dentry_sdcard_dir(base) &&
 +				   susfs_is_sus_sdcard_d_name_found(last.name))
 +		{
-+			dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++			dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +			goto skip_orig_flow;
 +		}
 +	}
 +#endif
- 	dentry = lookup_one_qstr_excl(&last, path.dentry, lookup_flags);
+ 	dentry = __lookup_hash(&last, path.dentry, lookup_flags);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	if (dentry && !IS_ERR(dentry) && dentry->d_inode && base->d_inode && mnt &&
-+		susfs_is_inode_sus_path(mnt_idmap(mnt), dentry->d_inode))
++		susfs_is_inode_sus_path(dentry->d_inode))
 +	{
 +		dput(dentry);
-+		dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++		dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +	}
 +skip_orig_flow:
 +#endif
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
- 
+ 		/* Why not before? Because we want correct error value */
 @@ -4921,6 +5209,10 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
  	unsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET;
  	bool should_retry = false;
- 	int error = -EINVAL;
+ 	int error;
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	struct dentry *base;
 +	struct vfsmount *mnt;
 +#endif
  
  	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
- 		goto put_names;
-@@ -4962,9 +5254,35 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
+ 		return -EINVAL;
+@@ -4749,8 +5041,34 @@
  
  retry_deleg:
  	trap = lock_rename(new_path.dentry, old_path.dentry);
@@ -580,32 +599,31 @@
 +		if (susfs_is_base_dentry_android_data_dir(base) &&
 +			susfs_is_sus_android_data_d_name_found(old_last.name))
 +		{
-+			old_dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++			old_dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +			goto skip_orig_flow1;
 +		} else if (susfs_is_base_dentry_sdcard_dir(base) &&
 +				   susfs_is_sus_sdcard_d_name_found(old_last.name))
 +		{
-+			old_dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++			old_dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +			goto skip_orig_flow1;
 +		}
 +	}
 +#endif
  
- 	old_dentry = lookup_one_qstr_excl(&old_last, old_path.dentry,
- 					  lookup_flags);
+ 	old_dentry = __lookup_hash(&old_last, old_path.dentry, lookup_flags);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	if (old_dentry && !IS_ERR(old_dentry) && old_dentry->d_inode && base->d_inode && mnt &&
-+		susfs_is_inode_sus_path(mnt_idmap(mnt), old_dentry->d_inode))
++		susfs_is_inode_sus_path(old_dentry->d_inode))
 +	{
 +		dput(old_dentry);
-+		old_dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++		old_dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +	}
 +skip_orig_flow1:
 +#endif
  	error = PTR_ERR(old_dentry);
  	if (IS_ERR(old_dentry))
  		goto exit3;
-@@ -4972,8 +5290,34 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
+@@ -4758,7 +5076,33 @@ static int do_renameat2(int olddfd, const char __user *oldname, int newdfd,
  	error = -ENOENT;
  	if (d_is_negative(old_dentry))
  		goto exit4;
@@ -616,24 +634,23 @@
 +		if (susfs_is_base_dentry_android_data_dir(base) &&
 +			susfs_is_sus_android_data_d_name_found(new_last.name))
 +		{
-+			new_dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++			new_dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +			goto skip_orig_flow2;
 +		} else if (susfs_is_base_dentry_sdcard_dir(base) &&
 +				   susfs_is_sus_sdcard_d_name_found(new_last.name))
 +		{
-+			new_dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++			new_dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +			goto skip_orig_flow2;
 +		}
 +	}
 +#endif
- 	new_dentry = lookup_one_qstr_excl(&new_last, new_path.dentry,
- 					  lookup_flags | target_flags);
+ 	new_dentry = __lookup_hash(&new_last, new_path.dentry, lookup_flags | target_flags);
 +#ifdef CONFIG_KSU_SUSFS_SUS_PATH
 +	if (new_dentry && !IS_ERR(new_dentry) && new_dentry->d_inode && base->d_inode && mnt &&
-+		susfs_is_inode_sus_path(mnt_idmap(mnt), new_dentry->d_inode))
++		susfs_is_inode_sus_path(new_dentry->d_inode))
 +	{
 +		dput(new_dentry);
-+		new_dentry = lookup_one_qstr_excl(&susfs_fake_qstr_name, base, lookup_flags);
++		new_dentry = __lookup_hash(&susfs_fake_qstr_name, base, lookup_flags);
 +	}
 +skip_orig_flow2:
 +#endif
